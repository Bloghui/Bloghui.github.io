{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Spring","slug":"Spring","date":"2022-07-15T08:17:40.000Z","updated":"2022-07-15T08:19:15.337Z","comments":true,"path":"2022/07/15/Spring/","link":"","permalink":"http://example.com/2022/07/15/Spring/","excerpt":"","text":"IOC1234567891011@Test public void testUser()&#123; //1、加载spring的配置文件 ApplicationContext context= new ClassPathXmlApplicationContext(&quot;brean1.xml&quot;); //2、获取配置创建的对象 Users user=context.getBean(&quot;user&quot;,Users.class); //3、调用方法 user.printServlet();&#125; Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： ​ 图1-1 传统应用程序示意图 当有了IoC&#x2F;DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: ​ 图1-2有IoC&#x2F;DI容器后程序结构示意图 概念和原理 控制反转。把对象创建和对象之间的调用过程，交给Spring进行管理； 使用IOC的目的：为了耦合度降低； IOC底层原理 xml解析、工厂模式、反射 IOC过程： 1234567891011//1、xml配置文件，配置创建的对象&lt;bean id =&quot;dao&quot; class=&quot;com.xxxx.lihui&quot;&gt;&lt;/bean&gt;//2、有service类和dao类，创建工厂类 class UserFactory&#123; public static UserDao getDao()&#123; String classValue=class 属性值；//xml解析 &lt;!--通过反射创建对象--&gt; Class class=Class forName(classValue); return (UserDao)class.newInstance(); &#125; &#125; IOC(接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂； Spring提供IOC容器实现两种方式：（两个接口）； BeanFactory：IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用 ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 BeanFactory加载配置文件时候不会创建对象，在获取对象（使用）才会创建对象； ApplicationContext加载配置文件时候会把配置文件对象进行创建； IOC操作Bean管理什么是Bean管理Bean管理指的是两个操作： （1）Spring创建对象 （2）Spring注入属性 Bean管理操作（1）基于xml配置文件方式实现； （2）基于注解方式实现； 基于xml方式123456789101112131415161718192021222324252627282930313233343536371、基于xml方式创建对象 &lt;!--为Users类对象创建--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.xxxx.lihui.Users&quot;&gt;&lt;/bean&gt; （1）在spring配置文件中，使用bean标签，标签中添加对应的属性，就可以实现对象的创建； （2）在bean标签中有很多属性，常用的属性： *id属性：唯一的标识 *class属性：类的全路径（包类路径） *name属性：name中可以加特殊符号 （3）创建对象的时候，默认执行无参构造方法 2、基于xml方式注入属性 （1）DI:依赖注入，就是注入属性（创建对象的基础之上）DI是ＩＯＣ的一种具体实现 第一种注入方式：使用ｓｅｔ方式 (2)在spring配置文件中配置对象创建,配置属性注入 &lt;!--配置Book类对象创建--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.xxxx.lihui.Book&quot;&gt; &lt;!--使用property完成属性注入--&gt; &lt;property name=&quot;bookName&quot; value=&quot;计算机网络&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 第二种注入方式: 使用有参数构造进行注入 &lt;!--配置Order类对象创建--&gt; &lt;bean id=&quot;order&quot; class=&quot;com.xxxx.lihui.Order&quot;&gt; &lt;!--默认无参构造--&gt; &lt;constructor-arg name=&quot;orderName&quot; value=&quot;abc&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=&quot;address&quot; value=&quot;China&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 《constructor n.构造函数，构造器，建造者》 《arg (函数的)自变量》 3、p名称空间注入 使用p名称空间注入，可以简化基于xml配置方式 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; &lt;bean id=&quot;book&quot; class=&quot;com.xxxx.lihui.Book&quot; p:bookName=&quot;西游记&quot; &gt; &lt;!--使用p名称空间简化xml配置方式--&gt; &lt;/bean&gt; xml注入其他类型属性1、字面量 （1）null值 123&lt;property name=&quot;bookAuthor&quot;&gt; &lt;null&gt;&lt;/null&gt;&lt;/property&gt; ​ (2)属性值包含特殊符号 1234 &lt;property name=&quot;bookStatus&quot;&gt; &lt;value&gt;&lt;![CDATA[&lt;&lt;奥里给&gt;&gt;]]&gt;&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 2、注入属性-外部bean 12345678910111213（1）创建两个类service类和dao类（2）在service调用dao里面的方法（3）在spring配置文件中进行配置 &lt;!--service和dao对象创建--&gt; &lt;bean id=&quot;userDaoImpl&quot; class=&quot;dao.UserDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;userService&quot; class=&quot;service.UserService&quot;&gt; &lt;!--注入userDao对象 name属性：类里面的属性名称 ref属性：创建userDao对象bean标签的id值 --&gt; &lt;property name=&quot;userDao &quot; ref=&quot;userDaoImpl&quot;&gt; &lt;/property&gt; &lt;/bean&gt; 3、注入属性-内部bean 和级联赋值 123456789101112131415(1)一对多关系：部门和员工一个部门有多个员工，一个员工属于一个部门部门是一，员工是多（2）在实体类之间表示一对多关系 &lt;!--配置Emp类对象创建--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.xxxx.lihui.bean.Emp&quot;&gt; &lt;property name=&quot;ename&quot; value=&quot;李辉&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--设置对象类型属性--&gt; &lt;property name=&quot;dept&quot;&gt; &lt;bean id=&quot;deptment&quot; class=&quot;com.xxxx.lihui.bean.Dept&quot;&gt; &lt;property name=&quot;Dname&quot; value=&quot;安保部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 级联赋值 12345678910111213141516171819202122232425262728293031（1）写法一&lt;!--级联赋值--&gt; &lt;bean id=&quot;emp&quot; class=&quot;com.xxxx.lihui.bean.Emp&quot;&gt; &lt;!--设置两个普通的属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;李辉&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.xxxx.lihui.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;（2）写法二//生成get方法（级联赋值操作） public Dept getDept() &#123; return dept; &#125; &lt;bean id=&quot;emp&quot; class=&quot;com.xxxx.lihui.bean.Emp&quot;&gt; &lt;!--设置两个普通的属性--&gt; &lt;property name=&quot;ename&quot; value=&quot;李辉&quot;&gt;&lt;/property&gt; &lt;property name=&quot;gender&quot; value=&quot;男&quot;&gt;&lt;/property&gt; &lt;!--级联赋值--&gt; &lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dept.dname&quot; value=&quot;技术部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;dept&quot; class=&quot;com.xxxx.lihui.bean.Dept&quot;&gt; &lt;property name=&quot;dname&quot; value=&quot;财务部&quot;&gt;&lt;/property&gt; &lt;/bean&gt; xml注入集合属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081821、注入数组类型属性&lt;bean id=&quot;stu&quot; class=&quot;com.xxxx.lihui.collectiontype.Student&quot;&gt; &lt;!--数组类型属性注入--&gt; &lt;property name=&quot;course&quot;&gt; &lt;list&gt; &lt;value&gt;java程序设计&lt;/value&gt; &lt;value&gt;数据库技术&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; 2、注入list集合类型属性 &lt;!--list属性注入--&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;张三&lt;/value&gt; &lt;value&gt;李四&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;3、注入Map集合类型属性 &lt;!--map类型属性注入--&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;JAVA&quot; value=&quot;java&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;Database&quot; value=&quot;db&quot;&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;4、set类型属性注入 &lt;!--set类型属性注入--&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;MySQL&lt;/value&gt; &lt;value&gt;SQL&lt;/value&gt; &lt;/set&gt; &lt;/property&gt;5、在集合里面设置对象类型值 &lt;!--创建多个course对象--&gt; &lt;bean id=&quot;course1&quot; class=&quot;com.xxxx.lihui.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;数据结构&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;course2&quot; class=&quot;com.xxxx.lihui.collectiontype.Course&quot;&gt; &lt;property name=&quot;cname&quot; value=&quot;数据结构&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--list集合类型，值为对象--&gt; &lt;property name=&quot;courseList&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;course1&quot;&gt;&lt;/ref&gt; &lt;ref bean=&quot;course2&quot;&gt;&lt;/ref&gt; &lt;/list&gt; &lt;/property&gt;6、把集合注入部分提取出来（1）在spring配置文件中引入名称空间 util&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;&gt;&lt;/beans&gt;(2)使用util标签完成list集合注入提取 &lt;!--提取list集合类型属性注入--&gt; &lt;util:list id=&quot;list&quot;&gt; &lt;value&gt;计算机科学与技术&lt;/value&gt; &lt;value&gt;物联网&lt;/value&gt; &lt;value&gt;软件工程&lt;/value&gt; &lt;/util:list&gt; &lt;!--提取list集合类型属性注入使用--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.xxxx.lihui.collectiontype.Book&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;list&quot;&gt;&lt;/property&gt; &lt;/bean&gt; IOC操作Bean管理（FactoryBean） 1、Spring有两种Bean，一种是普通bean，另一种是工厂bean(FactoryBean) 2、普通bean:在spring配置文件中定义bean类型就是返回类型 3、工厂bean：在配置文件定义bean类型可以和返回类型不一样；1、 第一步：创建一个类，让这个类作为工厂bean，实现接口FactoryBean 12public class MyBean implements FactoryBean&lt;Course&gt;&#123;&#125; 第二步：实现接口里面的方法，在实现方法中定义返回类型； 123456789101112131415161718/*定义返回bean* */@Overridepublic Course getObject() throws Exception &#123; Course course=new Course(); course.setCname(&quot;testBean&quot;); return course;&#125;@Overridepublic Class&lt;?&gt; getObjectType() &#123; return null;&#125;@Overridepublic boolean isSingleton() &#123; return FactoryBean.super.isSingleton();&#125; 12//bean配置文件 &lt;bean id=&quot;mybean&quot; class=&quot;com.xxxx.lihui.factoryBean.MyBean&quot;&gt;&lt;/bean&gt; IOC操作Bean管理（bean作用域） 1、在spring里面，设置创建bean是但是你还是多实例 2、在spring里面，默认情况下，bean是一个单实例 12345678910111213 @Test public void test()&#123; //加载spring配置文件 ApplicationContext context=new ClassPathXmlApplicationContext(&quot;brean1.xml&quot;); //获取配置创建对象 Book book1 =context.getBean(&quot;book&quot;,Book.class); Book book2 =context.getBean(&quot;book&quot;,Book.class); System.out.println(book1); System.out.println(book2); &#125;com.xxxx.lihui.Book@2fd66ad3com.xxxx.lihui.Book@2fd66ad3 3、如何设置单实例还是多实例 （1）在spring配置文件中bean标签里面有属性（scope）用于设置 （2）scope属性值 第一个值 默认值，singleton ，表示单实例对象 123&lt;bean id=&quot;book&quot; class=&quot;com.xxxx.lihui.collectiontype.Book&quot; scope=&quot;singleton&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;list&quot;&gt;&lt;/property&gt;&lt;/bean&gt; 第二个 prototype ，表示多实例对象 12345678910&lt;!--提取list集合类型属性注入--&gt;&lt;util:list id=&quot;list&quot;&gt; &lt;value&gt;计算机科学与技术&lt;/value&gt; &lt;value&gt;物联网&lt;/value&gt; &lt;value&gt;软件工程&lt;/value&gt;&lt;/util:list&gt;&lt;!--提取list集合类型属性注入使用--&gt;&lt;bean id=&quot;book&quot; class=&quot;com.xxxx.lihui.collectiontype.Book&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;list&quot; ref=&quot;list&quot;&gt;&lt;/property&gt;&lt;/bean&gt; com.xxxx.lihui.collectiontype.Book@aecb35acom.xxxx.lihui.collectiontype.Book@5fcd892a (3)singleton和prototype区别 第一 singleton单实例，prototype多实例 第二设置scope值是singleton时候，加载spring配置文件时候就会创建一个单实例对象 ​ 设置scope值是prototype时候，不是在加载spring配置文件创建对象，在调用getBean方法时候创建多实例对象； request session IOC操作Bean管理（bean生命周期） 1、生命周期 （1）从对象创建到对象销毁的过程 2、bean生命周期 （1）通过构造器创建bean实例（无参数构造） （2）为bean的属性设置值和对其他bean的引用（调用类中set方法） （3）调用bean初始化的方法（需要进行配置） （4）bean可以使用（对象获取到了） （5）当容器在关闭的时候，调用bean的销毁方法（需要进行配置销毁方法） 3、演示bean生命周期 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Orders &#123; private String OName; public Orders() &#123; System.out.println(&quot;第一步，执行无参构造方法创建bean实例&quot;); &#125; public void setOName(String OName) &#123; System.out.println(&quot;第二步，调用set方法设置属性值&quot;); this.OName = OName; &#125; //创建执行初始化的方法 public void initMethod()&#123; System.out.println(&quot;第三步，执行初始化的方法&quot;); &#125; //创建执行销毁的方法 public void destoryMethod()&#123; System.out.println(&quot;第五步，执行销毁方法&quot;); &#125;&#125;//bean配置文件&lt;/bean&gt; &lt;bean id=&quot;mybean&quot; class=&quot;com.xxxx.lihui.factoryBean.MyBean&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;orders&quot; class=&quot;com.xxxx.lihui.bean.Orders&quot; init-method=&quot;initMethod&quot; destroy-method=&quot;destoryMethod&quot;&gt; &lt;property name=&quot;OName&quot; value=&quot;小米k40游戏增强版&quot;&gt;&lt;/property&gt; &lt;/bean&gt; //测试方法 @Test /*1、加载spring配置文件 * 2、获得配置创建对象 * 3、调用方法 * * */ public void testOrders()&#123; ApplicationContext context=new ClassPathXmlApplicationContext(&quot;bean4.xml&quot;); Orders order=context.getBean(&quot;orders&quot;,Orders.class); System.out.println(&quot;第四步，获取创建的bean实例对象&quot;); //手动让bean实例销毁 ((ClassPathXmlApplicationContext)context).close(); &#125;ApplicationContext中没有close方法，强转成子类ClassPathXmlApplicationContext`第一步，执行无参构造方法创建bean实例``第二步，调用set方法设置属性值``第三步，执行初始化的方法``第四步，获取创建的bean实例对象``第五步，执行销毁方法` 4、bean的后置处理器，bean的生命周期有七步 （1）通过构造器创建bean实例（无参数构造） （2）为bean的属性设置值和对其他bean的引用（调用类中set方法） （3）把bean实例传递bean后置处理器的方法 1postProcessBeforeInitializatio （4）调用bean初始化的方法（需要进行配置） （5）把bean实例传递bean后置处理器的方法 1postProcessAfterInitialization （6）bean可以使用（对象获取到了） （7）当容器在关闭的时候，调用bean的销毁方法（需要进行配置销毁方法） 5、演示添加后置处理器效果 （1）创建类，实现接口BeanPostProcessor，创建后置处理器 1234567891011121314public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之前执行的方法&quot;); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(&quot;在初始化之后执行的方法&quot;); return bean; &#125;&#125; 123&lt;!--为当前配置文件的所有bean都配置后置处理器--&gt;&lt;!--配置后置处理器--&gt;&lt;bean id=&quot;mybeanpost&quot; class=&quot;com.xxxx.lihui.bean.MyBeanPost&quot;&gt;&lt;/bean&gt; IOC操作Bean管理（xml自动装配） 1、什么是自动装配 （1）根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入 2、演示自动装配过程 12345678910111213 &lt;!--实现自动装配 bean标签属性autowire.配置自动装配 autowire属性常用两个值： byName根据属性名称注入， 注入值的id值和类属性名称一样 byType根据属性类型注入 --&gt;&lt;bean id=&quot;emp&quot; class=&quot;com.xxxx.lihui.autowire.Emp&quot; autowire=&quot;byName&quot;&gt; &lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;&lt;/bean&gt; IOC操作Bean管理（外部属性文件） 1、直接配置数据库信息 （1）配置德鲁伊连接池 （2）引入德鲁伊连接池依赖jar包 2、引入外部属性文件配置数据库连接池 (1)创建外部属性文件，properties格式文件，写数据库信息 1234jdbc.driverclass=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/userdbjdbc.username=rootjdbc.password=lihui104715 (2)把外部properties属性文件引入到spring配置文件中 1234567*引入context名称空间 xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;*在spring配置文件中使用标签引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; 12345678910&lt;bean id=&quot;druid&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!--驱动名称--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverclass&#125;&quot;&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;!--连接数据库用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;!--连接数据库密码--&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; IOC操作Bean管理（基于注解方式） 1、什么是注解 （1）注解是代码特殊标记，格式：@注解名称（属性名称&#x3D;属性值，属性名称&#x3D;属性值……） （2）使用注解，注解作用在类上面，方法上面，属性上面 （3）使用注解的目的：简化xml配置 2、Spring针对Bean管理中创建对象提供注解 （1）@Component （2）@Service （3）@Controller （4）@Repository *上面的四个注解功能是一样的，都可以用来创建bean实例 3、基于注解方式实现对象创建 第一步：引入依赖 aop依赖 第二步：开启组件扫描 12345&lt;!--开启组件扫描1、扫描多个包，多个包使用逗号隔开2、扫描包上层目录--&gt;&lt;context:component-scan base-package=&quot;demo,service&quot;&gt;&lt;/context:component-scan&gt; 第三步：创建类，在类上面添加创建对象注解 12345678910/*在注解里面value属性值可以省略不写* 默认值是类名称，首字母小写* DemoService --demoService* */@Component(value = &quot;demoservice&quot;) //&lt;bean id=&quot;DemoService&quot; class=&quot;..&quot;/&gt;public class DemoService &#123; public void add()&#123; System.out.println(&quot;service add……&quot;); &#125;&#125; 4、开启组件扫描细节配置 123456789101112131415&lt;!--示例1 --&gt;&lt;!--use-default-filters=&quot;false&quot; 表示现在不使用默认filter，自己配置filtercontext:include-filter，设置扫描那些内容 annotation:根据注解扫描--&gt;&lt;context:component-scan base-package=&quot;dao&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt;&lt;!--示例2 --&gt;&lt;!-- 下面配置扫描包所有内容context：exclude-filter：设置哪些内容不进行扫描--&gt;&lt;context:component-scan base-package=&quot;demo&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;&lt;/context:component-scan&gt; 5、基于注解方式实现属性注入 （1）@AutoWired：根据属性类型进行自动装配 第一步：把service和dao对象创建，在service和dao类添加创建对象注解 第二步：在service注入dao对象 1234567891011121314151617/*在注解里面value属性值可以省略不写* 默认值是类名称，首字母小写* DemoService --demoService* */@Service(value = &quot;demoservice&quot;) //&lt;bean id=&quot;DemoService&quot; class=&quot;..&quot;/&gt;public class DemoService &#123; /*定义dao类型对象 * 不需要添加set方法 * 添加注入属性注解 * */ @Autowired private DemoDao dao; public void add()&#123; System.out.println(&quot;service add……&quot;); dao.add(); &#125;&#125; （2）@Qualifier：根据属性名称进行注入 这个@Qualifier注解的使用，和上面的@Autowired一起使用 12@Autowired //根据类型进行注入@Qualifier(value = &quot;demoDaoImpl1&quot;)//根据名称注入 （3）@Resource：可以根据类型注入，可以根据名称注入 import javax.annotation.Resource; 12@Resource//根据类型注入*/@Resource(name = &quot;demoDaoImpl1&quot;)//根据名称注入 （4）@Value：注入普通类型属性 12@Value(value = &quot;abd&quot;)private String name; 6、完全注解开发 （1）创建配置类，代替xml配置文件 12345678910111213@Configuration//作为配置类，代替xml配置文件@ComponentScan(basePackages = &#123;&quot;dao&quot;,&quot;service&quot;&#125;)public class SpringConfig &#123;&#125;//编写测试类 public void test2()&#123; /* 1、加载spring配置类 2、获取配置创建的对象 * */ ApplicationContext context=new AnnotationConfigApplicationContext(SpringConfig.class); DemoService service=context.getBean(&quot;demoservice&quot;,DemoService.class); service.add(); &#125; AOPAOP（概念） 1、什么是AOP （1）面向切面编程（面向方面编程），利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP(底层原理) 1、AOP底层使用动态代理 （1）有两种情况动态代理 第一种 有接口情况，使用JDK动态代理 1、创建接口的实现类的代理对象 第二种 没有接口情况，使用CGLIB动态代理 CGLIB动态代理 1、创建当前类子类的代理对象 AOP(JDK动态代理) 1、使用JDK动态代理，使用Proxy类里面的方法创建代理对象 （1）调用newProxyInstance方法 参数1：类加载器 参数2：增强方法所在的类，这个类实现的接口，支持多个接口 参数3：实现这个接口InvocationHandler,创建对象代理，写增强的方法 2、编写JDK动态代理代码 （1）创建接口，定义方法 （2）创建接口的实现类，实现方法 （3）使用proxy类增强方法 1234567891011121314151617181920212223242526272829303132333435public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类代理对象 Class[] interfaces=&#123;UserAdd.class&#125;; UserAddImpl user=new UserAddImpl(); UserAdd dao= (UserAdd) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(),interfaces,new UserDaoProxy(user)); int temp=dao.add(1,2); System.out.println(&quot;结果：&quot;+temp); &#125;&#125;//创建代理对象代码class UserDaoProxy implements InvocationHandler&#123; /*1、把创建的是谁的代理对象，把谁传递过来 有参数的构造传递 * */ //逻辑的增强 private Object obj; public UserDaoProxy(Object obj)&#123; this.obj=obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法之前 System.out.println(&quot;方法执行之前&quot;+method.getName()+&quot;传递参数&quot;+ Arrays.toString(args)); //被增强方法执行 Object res=method.invoke(obj,args); //方法之后 System.out.println(&quot;方法执行之后&quot;+obj); return res; &#125;&#125; AOP（术语） 1、连接点：类里面那些方法可以被增强，称为连接点 2、切入点：实际被真正增强的方法，称为切入点 3、通知（增强）： （1）实际增强的部分称为通知 （2）通知有多种类型 *前置通知 *后置通知 *环绕通知 *异常通知 *最终通知（finally） 4、切面 是动作 （1）把通知应用到切入点过程 AOP操作（准备）1、spring框架一般都是基于AspectJ实现AOP操作 （1）什么是AspectJ *AspectJ不是Spring组成部分，独立AOP框架，一般把Aspectj和Spring框架一起使用，进行AOP操作 2、基于AspectJ实现AOP操作 （1）基于xml配置文件实现 （2）基于注解方式实现（使用） 3、在项目工程中引入AOP相关依赖 4、切入点表达式 （1）切入点表达式的作用：知道对那些类里面的那个方法进行增强 （2）语法结构： 1234567execution（[权限修饰符][返回类型][类全路径][方法名称]（[参数列表]））//举例1：com.xxxx.lihui.dao.UserDaoImpl.add execution(*com.xxxx.lihui.Dao.UserDaoImpl.add(...))//举例2：对com.xxxx.lihui.dao.UserDaoImpl类里面所有方法进行增强 execution (*com.xxxx.lihui.da0.UserDaoImpl.*())//举例3：对com.xxxx.lihui.dao中所有类，类中的所有方法进行增强 execution(*com.xxx.dao.*.*(..)) AOP操作（AspectJ注解）1、创建类，在类里面定义方法 2、创建增强类，创建方法，让不同方法代表不同通知类型 3、进行通知的配置 （1）在spring配置文件中，开启注解扫描 （2）使用注解创建User和User Proxy对象 （3）在增强类上面添加注解@Aspect （4）在spring配置文件中开启生成代理对象 4、配置不同类型的通知 （1）在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 123456789101112131415161718192021/*被增强的类*/ @Componentpublic class testAop &#123; public void add()&#123; System.out.println(&quot;add test successful……&quot;); &#125;&#125;/*增强的类*/ @Aspect @Componentpublic class testProxy &#123; //前置通知 @Before(value =&quot;execution(* AOP.testAop.add(..))&quot;) public void before()&#123; System.out.println(&quot;before testAop.add()……&quot;); &#125;&#125; 1234567891011&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;&lt;!--开启注解扫描--&gt; &lt;context:component-scan base-package=&quot;AOP&quot;&gt;&lt;/context:component-scan&gt; &lt;!--开启Aspectj生成代理对象--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 123456789101112131415161718192021222324252627282930313233343536//前置通知@Before(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void before()&#123; System.out.println(&quot;before testAop.add()……&quot;);&#125;//后置通知@After(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void after()&#123; System.out.println(&quot;after testAop.add()……&quot;);&#125;//最终通知@AfterReturning(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void afterReturning()&#123; System.out.println(&quot;afterReturning testAop.add()……&quot;);&#125;@AfterThrowing(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void afterThrowing()&#123; System.out.println(&quot;afterThrowing testAop.add()……&quot;);&#125;//环绕通知@Around(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前……&quot;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后……&quot;);&#125;环绕之前……before testAop.add()……add test successful……afterReturning testAop.add()……after testAop.add()……环绕之后…… 5、相同切入点抽取 123456789@Pointcut(value =&quot;execution(* AOP.testAop.add(..))&quot;)public void pointDemo()&#123; &#125;//前置通知@Before(value =&quot;pointDemo()&quot;)public void before()&#123; System.out.println(&quot;before testAop.add()……&quot;);&#125; 6、有多个增强类对同一个方法进行增强，设置增强优先级 （1）在增强类上面添加注解@Order（数字类型），数字类型值越小优先级越高 1234/*增强的类*/@Aspect@Component@Order(1) AOP（AspectJ配置文件）1、创建类，在类里面定义方法 2、创建增强类，创建方法，让不同方法代表不同通知类型 12345678910111213&lt;!--创建对象--&gt;&lt;bean id=&quot;book&quot; class=&quot;AOP.Book&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;bookProxy&quot; class=&quot;AOP.BookProxy&quot;&gt;&lt;/bean&gt;&lt;!--在spring中配置aop的增强--&gt;&lt;aop:config&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;p&quot; expression=&quot;execution(* AOP.Book.add(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;p&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; JdbcTemplateJdbcTemplate（概念）1、什么是JdbcTemplate （1）Spring框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库操作 2、准备工作 （1）引入相关jar包 （2）在spring配置文件中配置数据库 12345678910111213141516171819202122 &lt;!--开启组件扫描--&gt; &lt;context:component-scan base-package=&quot;dao,service,entity&quot;&gt;&lt;/context:component-scan&gt; &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt; &lt;!--直接配置连接池--&gt; &lt;bean id=&quot;druid&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;!--驱动名称--&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;jdbc.driverclass&#125;&quot;&gt;&lt;/property&gt; &lt;!--数据库地址--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt; &lt;!--连接数据库用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt; &lt;!--连接数据库密码--&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--JdbcTemplate对象--&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入druid(dataSource)--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druid&quot;&gt;&lt;/property&gt; &lt;/bean&gt;erty name=&quot;dataSource&quot; ref=&quot;druid&quot;&gt;&lt;/property&gt;&lt;/bean&gt; （4）创建service类，创建dao类，在dao注入jdbcTemplate对象 JdbcTemplate操作数据库（添加）123456789101112131415161718jdbcTemplate.update();//第一个参数 ：sql语句//第二个参数：可变参数，设置sql语句值@Componentpublic class BookDaoImpl implements BookDao&#123; //注入jdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) &#123; //创建sql语句 String sql=&quot;insert into userInfo value(?,?,?,?)&quot;; //调用方法实现 /*可用object[]数组*/ int update= jdbcTemplate.update(sql,user.getUserId(),user.getUserName(),user.getUserSex(),user.getUserAge()); &#125;&#125; JdbcTemplate操作数据库（删除）12345678910111213141516171819 //删除表中记录@Overridepublic void delete(User user) &#123; //创建sql语句 String sql=&quot;delete from userinfo where username=?&quot;; Object []args=&#123;user.getUserName()&#125;; int temp=jdbcTemplate.update(sql,args); System.out.println(temp);&#125;//更新表中数据@Overridepublic void update(User user) &#123;String sql=&quot;update userinfo set username=? where uerId=?&quot;;Object []args=&#123;&quot;奥里给&quot;,user.getUserId()&#125;; int temp=jdbcTemplate.update(sql,args); System.out.println(temp);&#125; JdbcTemplate操作数据库（查询返回某个值）1、查询表里面有多少条记录，返回是某个值 12345678select *from userinfo where username=&quot;测试&quot;;select count(*)from userinfo; jdbcTemplate.queryForObject(sql,Integer.class); //参数1：sql语句 //参数2：返回类型Class User user=jdbcTemplate.queryForObject(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),name); 2、使用JdbcTemplate去实现查询返回某个值代码 3、返回模型对象 JdbcTemplate操作数据库（批量操作）1、批量操作：操作表中的多条记录 2、jdbcTemplate实现批量添加操作 12345678@Overridepublic void batchAdd(List&lt;Object[]&gt; batchArgs) &#123; String sql=&quot;insert into userinfo value(?,?,?,?)&quot;; int ints[]=jdbcTemplate.batchUpdate(sql,batchArgs);&#125;//批量修改 事物概念1、什么叫事物 （1）事物是数据库操作的最基本的单元。逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 （2）典型场景：银行转账 2、事物的四个特性（ACID） （1）原子性 （2）一致性 （3）隔离性 （4）持久性 事物操作（搭建事物操作环境）web视图层，service层(业务层)，Dao（数据库操作，不写业务） 事物操作（Spring事物管理）1、事物添加到JavaEE三层结构的Service层（业务逻辑层） 2、在Spring进行事物管理操作 （1）有两种方式：编程式事物管理和声明式事务管理（使用） 3、声明式事物管理 （1）基于注解方式 （2）基于xml配置文件方式 4、在Spring进行声明式事物管理，底层使用AOP 5、Spring事物管理API （1）提供了一个接口，代表事物管理器，这个接口针对不同框架提供了不同的实现类 PlatformTransactionManager 注解声明式事物管理123456789&lt;!-- 创建事物管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druid&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启事务注解--&gt; &lt;!--引入tx标签--&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt; 在Serive类上加注解 12345678910111213141516171819202122232425262728293031323334@Transactional（1）可以添加到类上面，也可以添加到方法上面（2）如果把这个注解添加在类上面，这个类里面所有的方法都添加事物（3）如果把这个注解添加到方法上面，为这个方法添加事物声明式事物管理参数配置1、在service类上面添加注解@Transactionalpropagation:表示事务传播行为（1）多事务方法进行调用，这个过程中事物使如何进行管理的事务方法：对数据库表数据进行变化的操作事务方法调用非事务方法Spring框架中，针对传播行为有七种Spring中七种事务传播行为事务的传播行为，默认值为 Propagation.REQUIRED。可以手动指定其他的事务传播行为，如下： - Propagation.REQUIRED 如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。 - Propagation.SUPPORTS 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。 - Propagation.MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。 - Propagation.REQUIRES_NEW 重新创建一个新的事务，如果当前存在事务，延缓当前的事务。 - Propagation.NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。 - Propagation.NEVER 以非事务的方式运行，如果当前存在事务，则抛出异常。 - Propagation.NESTED 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。ioslation：事物隔离级别timeout：超时时间readOnly:是否只读rollbackFor：回滚noRollbackFor :不回滚 事务隔离级别 （1）事务有特性称为隔离性，多事物操作之间不会产生影响。不考虑隔离性产生很多问题 （2）有三个问题：脏读、不可重复读、虚（幻）读 （3）脏读：一个未提交的事务读取到了另一个未提交事务的数据 （4）不可重复读:一个未提交事务读取到另一个提交事务修改数据 （5幻读：一个未提交事务读取到提交事务添加数据 （6）通过设置事务的隔离性，解决读问题 DEFAULT 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.未提交读（read uncommited） :脏读，不可重复读，虚读都有可能发生已提交读 （read commited）:避免脏读。但是不可重复读和虚读有可能发生可重复读 （repeatable read） :避免脏读和不可重复读.但是虚读有可能发生.串行化的 （serializable） :避免以上所有读问题.Mysql 默认:可重复读Oracle 默认:读已提交 超时时间：timeout （1）事务需要在一定时间内进行提交，如果不提交进行回滚 （2）默认值是-1，设置时间以秒为单位进行计算 readOnly：是否只读 （1）读：查询操作，写：添加修改删除操作 （2）readOnly默认值false，表示可以查询，可以添加修改删除操作 （3）设置readOnly值为true，设置为true后，只能查询 rollbackFor：回滚 （1）设置出现哪些异常进行事务回滚 noRollbackFor:不回滚 （1）设置出现那些异常不进行事务回滚 事务操作（XML声明事务管理） 1、配置事务管理器 2、配置通知 3、配置切入点和切面 123456789101112131415161718192021222324&lt;!-- 创建事物管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&lt;!-- 注入数据源--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;druid&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;!-- 开启事务注解--&gt; &lt;!--引入tx标签--&gt; &lt;!--开启事务注解--&gt;&lt;!-- &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;&gt;&lt;/tx:annotation-driven&gt;--&gt; &lt;!--配置通知--&gt; &lt;tx:advice id=&quot;txAdvice&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定那种规则的方法上面添加事务--&gt; &lt;tx:method name=&quot;add*&quot; isolation=&quot;READ_UNCOMMITTED&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* dao.*.*(..))&quot;/&gt; &lt;!--配置切面--&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt&quot;&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 事务操作（完全注解式事务管理）12345678910111213141516171819202122232425262728@Configuration@ComponentScan(basePackages =&#123;&quot;dao&quot;,&quot;service&quot;&#125;)@EnableTransactionManagementpublic class TransactionConfig &#123; /*创建数据库连接池 * */ @Bean public DruidDataSource getDruidDataSource()&#123; DruidDataSource dataSource=new DruidDataSource(); dataSource.setDriverClassName(&quot;&quot;); return dataSource; &#125; //创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DruidDataSource dataSource)&#123; JdbcTemplate jdbcTemplate=new JdbcTemplate(); //注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DruidDataSource dataSource)&#123; DataSourceTransactionManager dataSourceTransactionManager=new DataSourceTransactionManager(); dataSourceTransactionManager.setDataSource(dataSource); return dataSourceTransactionManager; &#125; Spring5框架新功能1、整个Spring5框架的diamagnetic基于Java8，运行时兼容JDK9，许多不建议的类和方法在代码库中删除， 2、spring5.0框架自带通用日志封装 （1）spring5已经移除了Log4jConfigListener，建议使用Log4j2 （2）spring框架整合Log4j2 3、Spring5框架核心框架容器支持@Nullable注解 （1）@Nullable注解可以使用在方法上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空 函数式风格创建对象，交给spring进行","categories":[],"tags":[],"author":"John Doe"}],"categories":[],"tags":[]}